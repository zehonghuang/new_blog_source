<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Kubernetes的网络模型，总结网络故障排查核心思路 - 作为客体的类库</title>
  <meta property="og:title" content="Kubernetes的网络模型，总结网络故障排查核心思路 - 作为客体的类库" />
  <meta name="twitter:title" content="Kubernetes的网络模型，总结网络故障排查核心思路 - 作为客体的类库" />
  <meta name="description" content="本文旨在梳理网络模型，总结出通用并且高可行性的故障排查思路，并且能通过自动化检测减少中大规模集群的手动排查工作。


1


默认读者已熟悉四层/七层网络模型，相关概念不再赘述


一、Linux中的基础网络技术
这里只会提及相关的Linux指令，不深入技术原理，只会一笔带过。
1. Network namespace
我们知道两个POD的网络相互隔离，实际在操作系统中是通过命名空间实现的。
Network namespace用于支持网络协议栈的多个实例。通过对网络资源的隔离，就能在一个宿主机上虚拟出多个不同的网络环境。docker利用NS实现了不同容器的网络隔离。
Network namespace可以提供独立的路由表和iptables来设置包转发、nat以及ip包过滤等功能，提供完整且独立的协议栈。


1
2
3
4


## 创建一个新的网络命名空间
sudo ip netns add my_namespace
## 进入my_namespace的内部 shell 界面
sudo ip netns exec my_namespace bash


2. veth设备对
那如何我们如何为两个不同命名空间下的进程之间实现通信呢？
可以通过引入Veth设备对，Veth设备都是成对出现的，其中一端成为另一端的peer，在Veth设备的一端发送数据时，会将数据发送到另一端，并触发接收数据的操作。">
  <meta property="og:description" content="本文旨在梳理网络模型，总结出通用并且高可行性的故障排查思路，并且能通过自动化检测减少中大规模集群的手动排查工作。


1


默认读者已熟悉四层/七层网络模型，相关概念不再赘述


一、Linux中的基础网络技术
这里只会提及相关的Linux指令，不深入技术原理，只会一笔带过。
1. Network namespace
我们知道两个POD的网络相互隔离，实际在操作系统中是通过命名空间实现的。
Network namespace用于支持网络协议栈的多个实例。通过对网络资源的隔离，就能在一个宿主机上虚拟出多个不同的网络环境。docker利用NS实现了不同容器的网络隔离。
Network namespace可以提供独立的路由表和iptables来设置包转发、nat以及ip包过滤等功能，提供完整且独立的协议栈。


1
2
3
4


## 创建一个新的网络命名空间
sudo ip netns add my_namespace
## 进入my_namespace的内部 shell 界面
sudo ip netns exec my_namespace bash


2. veth设备对
那如何我们如何为两个不同命名空间下的进程之间实现通信呢？
可以通过引入Veth设备对，Veth设备都是成对出现的，其中一端成为另一端的peer，在Veth设备的一端发送数据时，会将数据发送到另一端，并触发接收数据的操作。">
  <meta name="twitter:description" content="本文旨在梳理网络模型，总结出通用并且高可行性的故障排查思路，并且能通过自动化检测减少中大规模集群的手动排查工作。


1


默认读者已熟悉四层/七层网络模型，相关概念不再赘述


一、Linux中的基础网络技术
这里只会提及相关的Linux指令，不深入技术原理，只会一笔带过。
1. Network namespace
我们知道两个POD的网络相互隔离，实际在操作系统中是通过命名空间实现的。 …">
  <meta name="author" content="金汤力"/>
  <meta property="og:site_name" content="作为客体的类库" />
  <meta property="og:url" content="https://example.com/kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.122.0">
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/style-dark.css" media="all and (prefers-color-scheme: dark)" />

  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/fontawesome/all.min.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">作为客体的类库</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-tags"><a href="/tags/" title="Tags">Tags</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Kubernetes的网络模型，总结网络故障排查核心思路</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>June 3, 2022</time></li>
        <li class="article-meta-categories">
          <a href="/categories/kubernetes/">
            <i class="fa-solid fa-folder"></i>
            Kubernetes
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">
            <i class="fa-solid fa-tag"></i>
            云原生
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/kubernetes/">
            <i class="fa-solid fa-tag"></i>
            Kubernetes
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/">
            <i class="fa-solid fa-tag"></i>
            网络通讯
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/cni/">
            <i class="fa-solid fa-tag"></i>
            CNI
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#一linux中的基础网络技术">一、Linux中的基础网络技术</a>
      <ul>
        <li><a href="#1-network-namespace">1. Network namespace</a></li>
        <li><a href="#2-veth设备对">2. veth设备对</a></li>
        <li><a href="#3-网桥bridge">3. 网桥bridge</a></li>
        <li><a href="#4-iptables转发功能">4. iptables转发功能</a></li>
        <li><a href="#5-vxlanip-in-ip">5. VxLan、IP-in-IP</a></li>
      </ul>
    </li>
    <li><a href="#二pod之间通信">二、POD之间通信</a>
      <ul>
        <li><a href="#同一个节点的pod之间">同一个节点的Pod之间</a></li>
        <li><a href="#跨节点的pod之间">跨节点的Pod之间</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>
      <p>本文旨在梳理网络模型，总结出通用并且高可行性的故障排查思路，并且能通过自动化检测减少中大规模集群的手动排查工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">默认读者已熟悉四层/七层网络模型，相关概念不再赘述
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="一linux中的基础网络技术">一、Linux中的基础网络技术</h2>
<p>这里只会提及相关的Linux指令，不深入技术原理，只会一笔带过。</p>
<h3 id="1-network-namespace">1. Network namespace</h3>
<p>我们知道两个POD的网络相互隔离，实际在操作系统中是通过命名空间实现的。</p>
<p>Network namespace用于支持网络协议栈的多个实例。通过对网络资源的隔离，就能在一个宿主机上虚拟出多个不同的网络环境。docker利用NS实现了不同容器的网络隔离。
Network namespace可以提供独立的路由表和iptables来设置包转发、nat以及ip包过滤等功能，提供完整且独立的协议栈。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 创建一个新的网络命名空间</span>
</span></span><span class="line"><span class="cl">sudo ip netns add my_namespace
</span></span><span class="line"><span class="cl"><span class="c1">## 进入my_namespace的内部 shell 界面</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> my_namespace bash
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-veth设备对">2. veth设备对</h3>
<p>那如何我们如何为两个不同命名空间下的进程之间实现通信呢？</p>
<p>可以通过引入Veth设备对，Veth设备都是成对出现的，其中一端成为另一端的peer，在Veth设备的一端发送数据时，会将数据发送到另一端，并触发接收数据的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo ip netns add ns1
</span></span><span class="line"><span class="cl">sudo ip netns add ns2
</span></span><span class="line"><span class="cl"><span class="c1">## 创建一对 veth 设备，这里我们命名为 veth0 和 veth1，注意当前设备对为创建在任何命名空间中</span>
</span></span><span class="line"><span class="cl">sudo ip link add veth0 <span class="nb">type</span> veth peer name veth1
</span></span><span class="line"><span class="cl"><span class="c1">## 将 veth0 分配到 ns1，将 veth1 分配到 ns2，将peer转移到各自的命名空间</span>
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> veth0 netns ns1
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> veth1 netns ns2
</span></span><span class="line"><span class="cl"><span class="c1">## 在ns1里能看到相关的设备信息</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ip link show
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class="m">1000</span>
</span></span><span class="line"><span class="cl">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class="line"><span class="cl">2: veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP mode DEFAULT group default qlen <span class="m">1000</span>
</span></span><span class="line"><span class="cl">    link/ether 01:23:45:67:89:ab brd ff:ff:ff:ff:ff:ff
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 为两个 veth 设备分配 IP 地址，确保它们在同一子网中</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ip addr add 192.168.1.1/24 dev veth0
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns2 ip addr add 192.168.1.2/24 dev veth1
</span></span><span class="line"><span class="cl"><span class="c1">## 启动两个接口</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ip link <span class="nb">set</span> veth0 up
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns2 ip link <span class="nb">set</span> veth1 up
</span></span><span class="line"><span class="cl"><span class="c1">## 可以在两个命名空间之间测试连接，可以从 ns1 ping ns2</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ping 192.168.1.2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 可以通过 ethtool 工具可以在一端查看对端设接口</span>
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ethtool -S veth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NIC statistics:
</span></span><span class="line"><span class="cl">     peer_ifindex: <span class="m">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-网桥bridge">3. 网桥bridge</h3>
<p>在有多个网络命名空间和多个veth设备对的情况下，即在本机有多个POD，使用网桥（bridge）可以提供更好的管理和网络连通性，它充当一个虚拟的交换机，可以将多个网络接口连接在一起，使它们在同一个网络层次中互相通信。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 创建并启动网桥</span>
</span></span><span class="line"><span class="cl">sudo ip link add name br0 <span class="nb">type</span> bridge
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> br0 up
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 类似 calico 这种，放在网桥的设备名称通常是 caliXXXXXXX，而在 Pod 或者容器中的设备名称被命名为 eth0</span>
</span></span><span class="line"><span class="cl">sudo ip link add veth0 <span class="nb">type</span> veth peer name br-veth0
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> br-veth0 master br0
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> br-veth0 up
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> veth0 netns ns1
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ip addr add 192.168.1.123/24 dev veth0
</span></span><span class="line"><span class="cl">sudo ip netns <span class="nb">exec</span> ns1 ip link <span class="nb">set</span> veth0 up
</span></span></code></pre></td></tr></table>
</div>
</div><p>经过以上创建veth设备和网桥后，执行<code>ip route</code>可以看到以下这行记录。calico为容器创建网络环境后，也会有类似的记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">blackhole 192.168.1.123/26 proto bird
</span></span><span class="line"><span class="cl">192.168.1.123 dev br-veth0 scope link
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 你在Kubernetes集群的节点执行同样的命令，能看到类似的记录</span>
</span></span><span class="line"><span class="cl">10.244.166.168 dev calie8098ed1v42d scope link
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-iptables转发功能">4. iptables转发功能</h3>
<p>Kubernetes中通常不直接访问Pod IP，而是通过Service的ClusterIP访问，ClusterIP是一个虚拟的逻辑IP，通过iptables进行负载均衡+转发</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 开启 IP 转发功能</span>
</span></span><span class="line"><span class="cl">sudo sysctl -w net.ipv4.ip_forward<span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 开启iptables支持对brigde的转发 </span>
</span></span><span class="line"><span class="cl">sudo sysctl net.bridge.bridge-nf-call-iptables<span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">sudo sysctl net.bridge.bridge-nf-call-ip6tables<span class="o">=</span><span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-vxlanip-in-ip">5. VxLan、IP-in-IP</h3>
<ul>
<li>VxLan</li>
</ul>
<p>目前主流CNI中，Flannel支持该模式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo modprobe vxlan
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 对点对可以用以下方式，比如仅有两个host分别是192.168.1.1和192.168.1.2</span>
</span></span><span class="line"><span class="cl"><span class="c1">## sudo ip link add vxlan0 type vxlan id 42 dev eth0 remote 192.168.1.2 dstport 4789</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 如果有多台机器，可以基于交换机自持的多播组，这里指定多播组239.1.1.1</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 在每台机器执行该指令</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 需要注意一点，Flannel是通过监听etcd的Node资源变化来在本机添加的，并不是通用交换机的多播组，这是为了兼顾更多的集群网络场景</span>
</span></span><span class="line"><span class="cl">sudo ip link add vxlan0 <span class="nb">type</span> vxlan id <span class="m">42</span> group 239.1.1.1 dev eth0 dstport <span class="m">4789</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 启动</span>
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> vxlan0 up
</span></span><span class="line"><span class="cl"><span class="c1">## 在每台host添加属于自己的虚拟IP范围</span>
</span></span><span class="line"><span class="cl">sudo ip addr add 10.0.0.1/24 dev vxlan0
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>IP-in-IP</li>
</ul>
<p>Kubernetes的默认CNI calico的默认模式，另外一种叫BGP</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo modprobe ipip
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 为每台机器创建有个ipip隧道，并且启动</span>
</span></span><span class="line"><span class="cl">sudo ip tunnel add tunl0 mode ipip <span class="nb">local</span> 192.168.1.1 ttl <span class="m">255</span>
</span></span><span class="line"><span class="cl">sudo ip link <span class="nb">set</span> tunl0 up
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 为每段子网以及对应的宿主机添加记录</span>
</span></span><span class="line"><span class="cl">sudo ip route add 10.0.0.2/24 via 192.168.1.2 dev tunl0 proto bird
</span></span><span class="line"><span class="cl">sudo ip route add 10.0.0.3/24 via 192.168.1.3 dev tunl0 proto bird
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>两种的区别</li>
</ul>
<p>就我个人所遇到的使用场景来说，我会觉得VxLan更适合大规模集群，因为本身支持多层的网络拓扑（IP-in-IP不支持），但是不断的解析报头封装报头也带来了额外网络开销，会带来不必要的延迟。</p>
<h2 id="二pod之间通信">二、POD之间通信</h2>
<p><img src="../static/images/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="dfsdf"></p>
<h3 id="同一个节点的pod之间">同一个节点的Pod之间</h3>
<h3 id="跨节点的pod之间">跨节点的Pod之间</h3>
    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older">
        <a href="/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/" data-toggle="tooltip" data-placement="top" title="【JRaft源码分析03】成员变化">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2017 Foo Bar</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="/about/" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-16F0MHER15"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-16F0MHER15', { 'anonymize_ip': false });
}
</script>


</body>
</html>
