<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>网络通讯 on 作为客体的类库</title>
    <link>https://example.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</link>
    <description>Recent content in 网络通讯 on 作为客体的类库</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; Copyright 2017 Foo Bar</copyright>
    <lastBuildDate>Sat, 13 Aug 2022 22:36:08 +0800</lastBuildDate>
    <atom:link href="https://example.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kube Proxy如何监听Service和Endpoint以及更新策略规则</title>
      <link>https://example.com/kube-proxy%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACservice%E5%92%8Cendpoint%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E8%A7%84%E5%88%99/</link>
      <pubDate>Sat, 13 Aug 2022 22:36:08 +0800</pubDate>
      <guid>https://example.com/kube-proxy%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACservice%E5%92%8Cendpoint%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E8%A7%84%E5%88%99/</guid>
      <description>&lt;p&gt;本文会探讨Kubernetes另一个核心网络组件Kube-Proxy，它承担着Service及其后端Pod对宿主机配置的影响。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一-先聊一下三个核心api&#34;&gt;一、 先聊一下三个核心API&lt;/h2&gt;&#xA;&lt;p&gt;这三个API在不同版本下的Kube-Proxy发挥着主要作用，尤其是后两者。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-service&#34;&gt;1. Service&lt;/h3&gt;&#xA;&lt;h3 id=&#34;2-endpointendpointslice&#34;&gt;2. Endpoint、EndpointSlice&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;EndpointSlice&lt;/code&gt;是在k8s 1.9版本开始支持的&lt;/p&gt;&#xA;&lt;h2 id=&#34;二kube-proxy的源码分析&#34;&gt;二、Kube-Proxy的源码分析&lt;/h2&gt;</description>
    </item>
    <item>
      <title>详细梳理Kubernetes的网络模型，总结网络故障排查核心思路</title>
      <link>https://example.com/kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 03 Jun 2022 14:26:11 +0800</pubDate>
      <guid>https://example.com/kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF/</guid>
      <description>&lt;p&gt;本文旨在梳理网络模型，总结出通用并且高可行性的故障排查思路，并且能通过自动化检测减少中大规模集群的手动排查工作。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;默认读者已熟悉四层/七层网络模型，相关概念不再赘述&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;一linux中的基础网络技术&#34;&gt;一、Linux中的基础网络技术&lt;/h2&gt;&#xA;&lt;p&gt;这里只会提及相关的Linux指令，不深入技术原理，只会一笔带过，不然文章会很冗长。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-network-namespace&#34;&gt;1. Network namespace&lt;/h3&gt;&#xA;&lt;p&gt;我们知道两个POD的网络相互隔离，实际在操作系统中是通过命名空间实现的。&lt;/p&gt;&#xA;&lt;p&gt;Network namespace用于支持网络协议栈的多个实例。通过对网络资源的隔离，就能在一个宿主机上虚拟出多个不同的网络环境。docker利用NS实现了不同容器的网络隔离。&#xA;Network namespace可以提供独立的路由表和iptables来设置包转发、nat以及ip包过滤等功能，提供完整且独立的协议栈。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;## 创建一个新的网络命名空间&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ip netns add my_namespace&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;## 进入my_namespace的内部 shell 界面&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; my_namespace bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;2-veth设备对&#34;&gt;2. veth设备对&lt;/h3&gt;&#xA;&lt;p&gt;那如何我们如何为两个不同命名空间下的进程之间实现通信呢？&lt;/p&gt;&#xA;&lt;p&gt;可以通过引入Veth设备对，Veth设备都是成对出现的，其中一端成为另一端的peer，在Veth设备的一端发送数据时，会将数据发送到另一端，并触发接收数据的操作。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
